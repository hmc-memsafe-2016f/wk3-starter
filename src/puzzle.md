1. In a_outlives_b, b is only live during the inner lexical scope, and and ra is set through puzzle() to a reference to a
In b_outlives_a, the opposite happens, and rb is set to a reference to b.
In a_outlives_b, this means that the &a passed to puzzle() is live for the entire function, whereas the &b passed to puzzle() is only live for the rest of the inner lexical scope.

2. Making the function 'a means that the lifetimes of the things that the function returns are both 'a. Since puzzle() returns a Option<&'a i32> and an Option<&'b i32>, and the function is only capable of returning Option<&'a i32>, there is a type mismatch. Furthermore, if the lifetime 'b is shorter than 'a, this definition of the function tries to enforce the references living longer than their data.

3. Again, Option<&'a i32> and Option<&'c i32> are not the same, so the function's return type does not match puzzle()'s return type. If 'c is longer than 'a or 'b, then the function would try to enforce the references living longer than their data.

4. If 'a and 'b are different, then forcing the references returned by F to live for the longest of these two lifetimes means that references that are only actually live for the shorter lifetime would be forced to be live for longer than their data, which is not ok.

5. The contstraints force 'a, 'b, and 'c to be equal to each other. This is the same as putting 'a in every spot where there is a lifetime in puzzle(). This works, insofar as if you actually pass it variables with the same lifetimes it will compile, but makes it impossible to pass in variables with different lifetimes, causing the compile errors in both a_outlives_b and b_outlives_a, since the lifetimes of a and b are different. In a_outlives_b, for example, the compiler can try to force the issue by making &b live longer than it should. However, it must live as long as &a, whose value is used in ra, so it must live for the entire rest of the function. However, since b itself is dropped at the end of the inner lexical scope, that would make &b invalid after the end of that scope, which is a problem because &b would live longer than b.

6. In a_outlives_b, since the &a that we pass to puzzle in the inner scope no longer has to be live after the end of the lexical scope, this allows &b to also drop at the end of that scope (since their lifetimes are constrained to be equal). Since a clearly outlives this scope, and b is also dropped at the end of the scope, it's no longer a problem since &b and b are dropped at the same time. The same is true for b_outlives_a.

7. for<'c> allows you to specify what kind of functions F can be. This means that you can not only specify the arguments of F, but for<'c> allows you to specify the lifetimes of those arguments. This is relevant for puzzle() because we want to return an Option<&'a i32> and an Option<&'b i32> from a &'a i32 and a &'b i32 respectively. This means that the lifetime of the returned reference from F must match the lifetime of the argument reference. This is expressed by using for<'c> to specify the output lifetime of F relative to the input lifetimes of F. In this case, the original code works because the compiler can recognize that F should return a reference with the same lifetime as the argument.
